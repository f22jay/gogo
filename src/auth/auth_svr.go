package auth

import (
	"bytes"
	"common"
	"crypto/md5"
	"encoding/gob"
	"encoding/hex"
	"errors"
	"fmt"
	"github.com/go-redis/redis"
	"log"
	"rpc"
	"strings"
	"time"
)

// AuthSvr logic impl
type AuthSvr struct{}

// ExpireDuation : token expire time : 10 min
var ExpireDuation = time.Duration(10 * 60 * 1e9)

// Md5 : return md5 str
func Md5(s string) string {
	h := md5.New()
	h.Write([]byte(s))
	return hex.EncodeToString(h.Sum(nil))
}

// LoginByPass : check username passwd
func (*AuthSvr) LoginByPass(req *LoginByPassReq, rsp *LoginByPassRsp) int {
	// qps test
	if req.UserAuth.Username == "qps" {
		rsp.Token = req.UserAuth.Username + req.UserAuth.Passwd
		return 0
	}
	userAuth := &UserAuth{}
	db := common.GetDb()
	if db == nil {
		log.Printf("Open mysql failed\n")
		return common.ErrDB
	}
	row := db.QueryRow("select username, passwd from user_auth where username = ? ", req.UserAuth.Username)
	if err := row.Scan(&userAuth.Username, &userAuth.Passwd); err != nil {
		log.Printf("scan failed, err:%v", err)
		return common.ErrDB
	}
	if req.UserAuth.Passwd != userAuth.Passwd {
		return common.ErrPass
	}

	rsp.Token = Md5(req.UserAuth.Username + time.Now().String())

	cl := redis.NewClient(&redis.Options{
		Addr: common.RedisAddr,
	})
	_, err := cl.Ping().Result()

	if err != nil {
		log.Println(err)
		return common.ErrRedis
	}
	err = cl.Set(rsp.Token, req.UserAuth.Username, ExpireDuation).Err()
	if err != nil {
		log.Println("set token ", rsp.Token, " expire err:", err)
	}
	return 0
}

// LoginByToken : svr impl
func (*AuthSvr) LoginByToken(req *LoginByTokenReq, rsp *LoginByTokenRsp) int {
	if req.Token == "" {
		return common.ErrArg
	}
	if req.Token == "test" { // for test req
		rsp.Username = "test"
		return 0
	}
	cl := redis.NewClient(&redis.Options{
		Addr: common.RedisAddr,
	})
	_, err := cl.Ping().Result()
	if err != nil {
		log.Println(err)
		return common.ErrRedis
	}

	rsp.Username, err = cl.Get(req.Token).Result()
	if err != nil {
		log.Println(err)
		return common.ErrRedis
	}

	err = cl.Set(req.Token, rsp.Username, ExpireDuation).Err()
	if err != nil {
		log.Println("set token expire err:", err)
	}

	return 0
}

// InsertData : insert test data
func InsertData(beg int) error {
	db := common.GetDb()
	if db == nil {
		log.Printf("Open mysql failed\n")
		return errors.New("open mysql err")

	}
	sql := "insert INTO users values"
	var value []string
	for i := beg; i < (10000 + beg); i++ {
		v := fmt.Sprintf("('test%d','test%d', 'test%d.jpg')", i, i, i)
		value = append(value, v)
	}
	sql = sql + strings.Join(value, ",")
	_, err := db.Exec(sql)
	if err != nil {
		log.Println(sql)
		return err
	}
	return nil
}

// Dispatcher req, dispatcher shoud be generated by code
func (auth *AuthSvr) Dispatcher(req *rpc.RequestPkg) (rsp *rpc.ResponsePkg) {
	rsp = new(rpc.ResponsePkg)
	if req.FuncName == "LoginByPass" {
		buf := new(bytes.Buffer)
		buf.Write(req.ReqBuf)
		dec := gob.NewDecoder(buf)
		getReq := new(LoginByPassReq)
		err := dec.Decode(getReq)
		if err != nil {
			rsp.RetCode = rpc.PkgDecodeErr
			log.Println(err)
			return
		}

		getRsp := new(LoginByPassRsp)
		ret := auth.LoginByPass(getReq, getRsp)

		// set rsp pkg
		rsp.RequestID = req.RequestID
		rsp.SvrName = req.SvrName
		rsp.FuncName = req.FuncName
		rsp.RetCode = int32(ret)

		// encode rsp pkg
		buf = new(bytes.Buffer)
		enc := gob.NewEncoder(buf)
		err = enc.Encode(getRsp)
		if err != nil {
			rsp.RetCode = rpc.PkgEncodeErr
			log.Println(err, getRsp)
		}
		rsp.RspBuf = buf.Bytes()
	}
	if req.FuncName == "LoginByToken" {
		buf := new(bytes.Buffer)
		buf.Write(req.ReqBuf)
		dec := gob.NewDecoder(buf)
		getReq := new(LoginByTokenReq)
		err := dec.Decode(getReq)
		if err != nil {
			rsp.RetCode = rpc.PkgDecodeErr
			log.Println(err)
			return
		}

		getRsp := new(LoginByTokenRsp)
		ret := auth.LoginByToken(getReq, getRsp)

		// set rsp pkg
		rsp.RequestID = req.RequestID
		rsp.SvrName = req.SvrName
		rsp.FuncName = req.FuncName
		rsp.RetCode = int32(ret)

		// encode rsp pkg
		buf = new(bytes.Buffer)
		enc := gob.NewEncoder(buf)
		err = enc.Encode(getRsp)
		if err != nil {
			rsp.RetCode = rpc.PkgEncodeErr
			log.Println(err, getRsp)
		}
		rsp.RspBuf = buf.Bytes()
	}

	return
}
